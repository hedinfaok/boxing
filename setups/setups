#!/usr/bin/env bash

set -euo pipefail

# ==============================================================================
# SETUPS - A bash utility for managing setup functions
# ==============================================================================

SETUPS_HOME=${SETUPS_HOME:-"$HOME/setups"}

# ==============================================================================
# MAIN ENTRY POINT
# ==============================================================================

setups_prepare(){
  local dirs_to_create
  SETUPS_BUILTINS=$(_setup_flags)
  
  # Ensure required directories exist
  dirs_to_create=("$SETUPS_HOME"/bin "$SETUPS_HOME"/profile.d)
  for dir in "${dirs_to_create[@]}"; do
    [ -d "$dir" ] || mkdir -p "$dir"
  done
  
  source_dir "$SETUPS_HOME"/preload.d
  source_dir "$SETUPS_HOME"/plugins.d
  source_dir "$SETUPS_HOME"/setups.d
  setups "$@"
}

# Flags
SETUPS_FORCE=""

# USAGE: setups [name] ... [name]
setups(){
  if [ -n "${DEBUG:-}" ]; then set -x; fi

  local skip_options=""
  for i in "${@}"; do
    case "$i" in
      --)
        skip_options="true"
        ;;
      --*)
        if [ -z "$skip_options" ]; then
          if declare -f "setup_$i" >/dev/null 2>&1; then
            "setup_$i" "$@"
          else
            printf "Error: Unknown option '%s'\n" "$i" >&2
            printf "Run 'setups --help' for available options.\n" >&2
            return 1
          fi
        fi
        ;;
      *)
        if declare -f "setup_$i" >/dev/null 2>&1; then
          printf "Running setups for %s ...\n\n" "$i"
          "setup_$i" "$@"
        else
          printf "Error: No setup function found for '%s'\n" "$i" >&2
          printf "Run 'setups --list' to see available setups.\n" >&2
          return 1
        fi
        ;;
    esac
  done

  if [ -n "${DEBUG:-}" ];then set +x; fi
}

# ==============================================================================
# CORE FUNCTIONS
# ==============================================================================

source_dir(){
  local dir="${1:-"$SETUPS_HOME"/setups.d}"
  local fnmatch="${2:-*.sh}"
  local file

  if [ -d "$dir" ]; then
    # Use nullglob to handle no matches gracefully
    shopt -s nullglob
    for file in "$dir"/"$fnmatch"; do
      if [ -r "$file" ]; then
        # shellcheck source=/dev/null
        . "$file"
      fi
    done
    shopt -u nullglob
  else
    mkdir -p "$dir" 2>/dev/null
  fi
}

# hedinfaok/chromeos-dotfiles/HEAD/setups/setups.d/base.sh
source_github(){
  local GITHUB_TOKEN=${GITHUB_TOKEN:-$(gh auth token)}
  local curl_opts=()
  local i url
  
  for i in "$@"; do
    url="https://raw.githubusercontent.com/$i"
    if [ -n "$GITHUB_TOKEN" ]; then
      curl_opts+=(
        -H
        "Authorization: token $GITHUB_TOKEN"
      )
    fi
    download "$url" "${curl_opts[@]}"
    source "$SETUPS_CTX_DOWNLOAD_PATH"
  done
}

# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

# Wrap sudo to allow running setups as root user when sudo is in the script
sudo(){
  if [ "$(id -u)" -ne 0 ]; then
    /usr/bin/sudo "$@"
  else
    "$@"
  fi
}

# Return true if file exists, false otherwise.
# Skips check and returns false if setups --force flag is set.
created(){
  local flag="-f"
  if [[ "$1" = -* ]]; then flag="$1"; shift; fi
  [ -z "$SETUPS_FORCE" ] && [ $flag "$1" ]
}
creates(){ created "$@"; }

# Run setup_* if command not found
needs(){
  for i in "$@"; do
    if ! command -v "$i" >/dev/null; then
      if declare -f "setup_$i" >/dev/null 2>&1; then
        "setup_$i"
      else
        printf "Error: No setup function found for '%s'\n" "$i" >&2
        return 1
      fi
    fi
  done
}

# url_path <url>, returns path part of URL
url_path(){
  local url="$(printf "%s" "$1" | cut -d\? -f1)"
  local path="$(printf "%s" "$url" | cut -d/ -f4-)"
  printf "/%s" "$path"
}

# Usage: download <url> [curl_opt]...[curl_opt], SETUPS_CTX_DOWNLOAD_PATH stores download path
download(){
  local url="$1"; shift
  
  # Basic URL validation
  if [[ ! "$url" =~ ^https?:// ]]; then
    printf "Error: URL must start with http:// or https://\n" >&2
    return 1
  fi
  
  local tmp_path="$(mktemp -d -t setups-download-XXXXXXXXXXXX)"/"$(url_path "$url")"
  local curl_opts=(--fail --progress-bar --create-dir -o "$tmp_path" --location -X GET "$@")

  printf "Download source: %s\nDownload destination: %s\n" "$url" "$tmp_path"
  SETUPS_CTX_DOWNLOAD_PATH=""
  curl "${curl_opts[@]}" "$url"
  export SETUPS_CTX_DOWNLOAD_PATH="$tmp_path"
}

# Usage: prompt_for_command <command> [args]...[args]
prompt_for_command(){
  local message="Do you want to $*"
  local command="$*"
  
  # Basic validation to prevent command injection
  if [[ "$command" =~ [';''&''|'] ]]; then
    printf "Error: Command contains potentially unsafe characters\n" >&2
    return 1
  fi
  
  while true; do
    read -p "$message [Y/n] " yn
    case $yn in
      [Yy]* ) $command; break;;
      [Nn]* ) exit;;
      * ) echo "Please answer yes or no.";;
    esac
  done
}


# ==============================================================================
# BUILTIN SETUP FUNCTIONS
# ==============================================================================

setup_--help(){
cat <<HEREDOC
Usage: setups [options] name [name ...]

Built-in options:
$SETUPS_BUILTINS

Plugin options:
$( _setup_list_plugins | grep . || printf "no plugins\n")

Environment: SETUPS_HOME=$SETUPS_HOME
Source: $SETUPS_SOURCE
HEREDOC
}

# Print plugin options, one per line
_setup_list_plugins(){
  local grep_opts=()

  for ignore in $SETUPS_BUILTINS; do
    grep_opts+=(-e)
    grep_opts+=("$ignore")
  done
  _setup_flags | grep -vF "${grep_opts[@]}"
}

setup_--version(){
  printf "%s.%s.%s-%s\n" 1 1 0 dumbledore
  setup_--checksum
}

setup_--checksum(){
  printf "checksum (SHA256): %s\n" "$(sha256sum "$BASH_SOURCE" | cut -d' ' -f1)"
}

# List sourced functions that start with "setup_--"
_setup_flags(){
  declare -F \
    | grep '^declare -f setup_--' \
    | cut -d' ' -f3 \
    | cut -d_ -f2-
}

# List sourced functions that start with "setup_"
setup_--list(){
  declare -F \
    | grep '^declare -f setup_' \
    | grep -v -e '^declare -f setup_--' -e '^declare -f setup__--' \
    | cut -d' ' -f3 \
    | cut -d_ -f2-
}

# Print the source function that matches setup_$1
setup_--print(){
  shift;
  local s
  for s in "$@"; do
    declare -f setup_"$s"
  done
  exit $?
}

# Load additional sources for setups
setup_--source(){
  shift; source "$1"; shift
  setups "$@"
  exit $?
}

# Load additional sources for setups from a directory
setup_--source-dir(){
  shift; source_dir "$1"; shift
  setups "$@"
  exit $?
}

# Load additional sources for setups from github
setup_--source-github(){
  shift; source_github "$1"; shift
  setups "$@"
  exit $?
}

setup_--force(){
  SETUPS_FORCE="--force"
}

setup_--readme(){
cat <<HEREDOC
Setups is a simple bash utility that sources files matching ~/setups/setups.d/*.sh
and runs shell functions that match setup_<name>.

Setups provides a convention for installing software that may not come from
the system package manager, so you can create repeatable experiences in your
shell.

Here is a realistic function to setup Homebrew (save in ~/setups/setups.d/homebrew.sh):

function setup_brew(){
  NONINTERACTIVE=1 /bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}

Now you can run the following to install homebrew:

$ setups brew

You can list all defined setups by running setups --list

Setups made my work easier, but don't take my word for it. Try it out today!
HEREDOC
}

setup_setups(){
  download https://raw.githubusercontent.com/hedinfaok/boxing/main/setups/setups
  chmod a+x "$SETUPS_CTX_DOWNLOAD_PATH"
  mv -f "$SETUPS_CTX_DOWNLOAD_PATH" "$SETUPS_HOME/bin/setups"
}

if [ "$0" == "${BASH_SOURCE[0]}" ]; then
  SETUPS_SOURCE="$(readlink -f "$0")"
  setups_prepare "$@";
else
  # When sourced, don't load local setups
  SETUPS_SOURCE="sourced from $0"
fi
